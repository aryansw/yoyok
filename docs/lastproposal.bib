@article{krust2018,
  author     = {Feng Wang and
                Fu Song and
                Min Zhang and
                Xiaoran Zhu and
                Jun Zhang},
  title      = {KRust: {A} Formal Executable Semantics of Rust},
  journal    = {CoRR},
  volume     = {abs/1804.10806},
  year       = {2018},
  url        = {http://arxiv.org/abs/1804.10806},
  eprinttype = {arXiv},
  eprint     = {1804.10806},
  timestamp  = {Mon, 14 Jan 2019 06:49:12 +0100},
  biburl     = {https://dblp.org/rec/journals/corr/abs-1804-10806.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@article{moura2009,
  author     = {Moura, Ana L\'{u}cia De and Ierusalimschy, Roberto},
  title      = {Revisiting Coroutines},
  year       = {2009},
  issue_date = {February 2009},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {31},
  number     = {2},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/1462166.1462167},
  doi        = {10.1145/1462166.1462167},
  abstract   = {This article advocates the revival of coroutines as a convenient general control abstraction. After proposing a new classification of coroutines, we introduce the concept of full asymmetric coroutines and provide a precise definition for it through an operational semantics. We then demonstrate that full coroutines have an expressive power equivalent to one-shot continuations and one-shot delimited continuations. We also show that full asymmetric coroutines and one-shot delimited continuations have many similarities, and therefore present comparable benefits. Nevertheless, coroutines are easier implemented and understood, especially in the realm of procedural languages.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {feb},
  articleno  = {6},
  numpages   = {31},
  keywords   = {generators, multitasking, Continuations}
}

@inproceedings{Wadler1990LinearTC,
  title     = {Linear Types can Change the World!},
  author    = {Philip Wadler},
  booktitle = {Programming Concepts and Methods},
  year      = {1990}
}

@article{gauthier2023,
  author = {Gauthier, Pierre},
  year   = {2023},
  month  = {01},
  pages  = {},
  title  = {SLIMalloc II: Making C Safer than the "Memory-Safe" Languages}
}

@inproceedings{Reed2015PatinaA,
  title  = {Patina : A Formalization of the Rust Programming Language},
  author = {Eric C. Reed},
  year   = {2015}
}

@article{pearce2021,
  author     = {Pearce, David J.},
  title      = {A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust},
  year       = {2021},
  issue_date = {March 2021},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {43},
  number     = {1},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/3443420},
  doi        = {10.1145/3443420},
  abstract   = {Rust is a relatively new programming language that has gained significant traction since its v1.0 release in 2015. Rust aims to be a systems language that competes with C/C++. A claimed advantage of Rust is a strong focus on memory safety without garbage collection. This is primarily achieved through two concepts, namely, reference lifetimes and borrowing. Both of these are well-known ideas stemming from the literature on region-based memory management and linearity/uniqueness. Rust brings both of these ideas together to form a coherent programming model. Furthermore, Rust has a strong focus on stack-allocated data and, like C/C++ but unlike Java, permits references to local variables.Type checking in Rust can be viewed as a two-phase process: First, a traditional type checker operates in a flow-insensitive fashion; second, a borrow checker enforces an ownership invariant using a flow-sensitive analysis. In this article, we present a lightweight formalism that captures these two phases using a flow-sensitive type system that enforces ‚Äútype and borrow safety.‚Äù In particular, programs that are type and borrow safe will not attempt to dereference dangling pointers. Our calculus core captures many aspects of Rust, including copy- and move-semantics, mutable borrowing, reborrowing, partial moves, and lifetimes. In particular, it remains sufficiently lightweight to be easily digested and understood and, we argue, still captures the salient aspects of reference lifetimes and borrowing. Furthermore, extensions to the core can easily add more complex features (e.g., control-flow, tuples, method invocation). We provide a soundness proof to verify our key claims of the calculus. We also provide a reference implementation in Java with which we have model checked our calculus using over 500B input programs. We have also fuzz tested the Rust compiler using our calculus against 2B programs and, to date, found one confirmed compiler bug and several other possible issues.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {apr},
  articleno  = {3},
  numpages   = {73},
  keywords   = {Rust, ownership, model checking, type theory}
}

@inproceedings{konrad2011,
  author    = {Anton, Konrad
               and Thiemann, Peter},
  editor    = {Page, Rex
               and Horv{\'a}th, Zolt{\'a}n
               and Zs{\'o}k, Vikt{\'o}ria},
  title     = {Typing Coroutines},
  booktitle = {Trends in Functional Programming},
  year      = {2011},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {16--30},
  abstract  = {A coroutine is a programming construct between function and thread. It behaves like a function that can suspend itself arbitrarily often to yield intermediate results and to get new inputs before returning a result. This facility makes coroutines suitable for implementing generator abstractions.},
  isbn      = {978-3-642-22941-1}
}

@inproceedings{Rou2017AS,
  title     = {ùïÇ: A Semantic Framework for Programming Languages and Formal Analysis Tools},
  author    = {Grigore Ro≈üu},
  booktitle = {Dependable Software Systems Engineering},
  year      = {2017}
}